<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Generic.Syntax.Bidirectional</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Pragma">--sized-types</a> <a id="34" class="Symbol">#-}</a>

<a id="39" class="Keyword">module</a> <a id="46" href="Generic.Syntax.Bidirectional.html" class="Module">Generic.Syntax.Bidirectional</a> <a id="75" class="Keyword">where</a>

<a id="82" class="Keyword">open</a> <a id="87" class="Keyword">import</a> <a id="94" href="Data.Product.html" class="Module">Data.Product</a>
<a id="107" class="Keyword">open</a> <a id="112" class="Keyword">import</a> <a id="119" href="Agda.Builtin.List.html" class="Module">Agda.Builtin.List</a>
<a id="137" class="Keyword">open</a> <a id="142" class="Keyword">import</a> <a id="149" href="Agda.Builtin.Equality.html" class="Module">Agda.Builtin.Equality</a>
<a id="171" class="Keyword">open</a> <a id="176" class="Keyword">import</a> <a id="183" href="Function.html" class="Module">Function</a>

<a id="193" class="Keyword">open</a> <a id="198" class="Keyword">import</a> <a id="205" href="Generic.Syntax.html" class="Module">Generic.Syntax</a>

<a id="221" class="Keyword">open</a> <a id="226" class="Keyword">import</a> <a id="233" href="StateOfTheArt.ACMM.html" class="Module">StateOfTheArt.ACMM</a> <a id="252" class="Keyword">using</a> <a id="258" class="Symbol">(</a><a id="259" href="StateOfTheArt.ACMM.html#321" class="Datatype">Type</a><a id="263" class="Symbol">;</a> <a id="265" href="StateOfTheArt.ACMM.html#340" class="InductiveConstructor">α</a><a id="266" class="Symbol">;</a> <a id="268" href="StateOfTheArt.ACMM.html#354" class="InductiveConstructor Operator">_`→_</a><a id="272" class="Symbol">)</a> <a id="274" class="Keyword">public</a>

<a id="282" class="Comment">-- We have an *untyped* language presented in a bidirectional manner</a>
<a id="351" class="Comment">-- where phases are statically checked</a>

<a id="391" class="Keyword">data</a> <a id="`Lang"></a><a id="396" href="Generic.Syntax.Bidirectional.html#396" class="Datatype">`Lang</a> <a id="402" class="Symbol">:</a> <a id="404" class="PrimitiveType">Set</a> <a id="408" class="Keyword">where</a>
  <a id="`Lang.App"></a><a id="416" href="Generic.Syntax.Bidirectional.html#416" class="InductiveConstructor">App</a> <a id="`Lang.Lam"></a><a id="420" href="Generic.Syntax.Bidirectional.html#420" class="InductiveConstructor">Lam</a> <a id="`Lang.Emb"></a><a id="424" href="Generic.Syntax.Bidirectional.html#424" class="InductiveConstructor">Emb</a> <a id="428" class="Symbol">:</a> <a id="430" href="Generic.Syntax.Bidirectional.html#396" class="Datatype">`Lang</a>
  <a id="`Lang.Cut"></a><a id="438" href="Generic.Syntax.Bidirectional.html#438" class="InductiveConstructor">Cut</a> <a id="442" class="Symbol">:</a> <a id="444" href="StateOfTheArt.ACMM.html#321" class="Datatype">Type</a> <a id="449" class="Symbol">→</a> <a id="451" href="Generic.Syntax.Bidirectional.html#396" class="Datatype">`Lang</a>

<a id="458" class="Keyword">data</a> <a id="Mode"></a><a id="463" href="Generic.Syntax.Bidirectional.html#463" class="Datatype">Mode</a> <a id="468" class="Symbol">:</a> <a id="470" class="PrimitiveType">Set</a> <a id="474" class="Keyword">where</a>
  <a id="Mode.Check"></a><a id="482" href="Generic.Syntax.Bidirectional.html#482" class="InductiveConstructor">Check</a> <a id="Mode.Infer"></a><a id="488" href="Generic.Syntax.Bidirectional.html#488" class="InductiveConstructor">Infer</a> <a id="494" class="Symbol">:</a> <a id="496" href="Generic.Syntax.Bidirectional.html#463" class="Datatype">Mode</a>

<a id="502" class="Comment">-- On top of the traditional Application and Lambda-Abstraction constructors,</a>
<a id="580" class="Comment">-- we have two change of direction ones: `Emb` which takes inferable terms and</a>
<a id="659" class="Comment">-- makes them checkable (it is enough to compare the inferred type to the</a>
<a id="733" class="Comment">-- candidate provided); and `Cut` which takes a checkable term and makes it</a>
<a id="809" class="Comment">-- inferrable thanks to a type-annotation.</a>

<a id="Lang"></a><a id="853" href="Generic.Syntax.Bidirectional.html#853" class="Function">Lang</a> <a id="858" class="Symbol">:</a> <a id="860" href="Generic.Syntax.html#497" class="Datatype">Desc</a> <a id="865" href="Generic.Syntax.Bidirectional.html#463" class="Datatype">Mode</a>
<a id="870" href="Generic.Syntax.Bidirectional.html#853" class="Function">Lang</a>  <a id="876" class="Symbol">=</a>  <a id="879" href="Generic.Syntax.html#527" class="InductiveConstructor">`σ</a> <a id="882" href="Generic.Syntax.Bidirectional.html#396" class="Datatype">`Lang</a> <a id="888" href="Function.html#1927" class="Function Operator">$</a> <a id="890" class="Symbol">λ</a> <a id="892" class="Keyword">where</a>
  <a id="900" href="Generic.Syntax.Bidirectional.html#416" class="InductiveConstructor">App</a>      <a id="909" class="Symbol">→</a> <a id="911" href="Generic.Syntax.html#569" class="InductiveConstructor">`X</a> <a id="914" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="917" href="Generic.Syntax.Bidirectional.html#488" class="InductiveConstructor">Infer</a> <a id="923" class="Symbol">(</a><a id="924" href="Generic.Syntax.html#569" class="InductiveConstructor">`X</a> <a id="927" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="930" href="Generic.Syntax.Bidirectional.html#482" class="InductiveConstructor">Check</a> <a id="936" class="Symbol">(</a><a id="937" href="Generic.Syntax.html#611" class="InductiveConstructor">`∎</a> <a id="940" href="Generic.Syntax.Bidirectional.html#488" class="InductiveConstructor">Infer</a><a id="945" class="Symbol">))</a>
  <a id="950" href="Generic.Syntax.Bidirectional.html#420" class="InductiveConstructor">Lam</a>      <a id="959" class="Symbol">→</a> <a id="961" href="Generic.Syntax.html#569" class="InductiveConstructor">`X</a> <a id="964" class="Symbol">(</a><a id="965" href="Generic.Syntax.Bidirectional.html#488" class="InductiveConstructor">Infer</a> <a id="971" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="973" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="975" class="Symbol">)</a> <a id="977" href="Generic.Syntax.Bidirectional.html#482" class="InductiveConstructor">Check</a> <a id="983" class="Symbol">(</a><a id="984" href="Generic.Syntax.html#611" class="InductiveConstructor">`∎</a> <a id="987" href="Generic.Syntax.Bidirectional.html#482" class="InductiveConstructor">Check</a><a id="992" class="Symbol">)</a>
  <a id="996" class="Symbol">(</a><a id="997" href="Generic.Syntax.Bidirectional.html#438" class="InductiveConstructor">Cut</a> <a id="1001" href="Generic.Syntax.Bidirectional.html#1001" class="Bound">σ</a><a id="1002" class="Symbol">)</a>  <a id="1005" class="Symbol">→</a> <a id="1007" href="Generic.Syntax.html#569" class="InductiveConstructor">`X</a> <a id="1010" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="1013" href="Generic.Syntax.Bidirectional.html#482" class="InductiveConstructor">Check</a> <a id="1019" class="Symbol">(</a><a id="1020" href="Generic.Syntax.html#611" class="InductiveConstructor">`∎</a> <a id="1023" href="Generic.Syntax.Bidirectional.html#488" class="InductiveConstructor">Infer</a><a id="1028" class="Symbol">)</a>
  <a id="1032" href="Generic.Syntax.Bidirectional.html#424" class="InductiveConstructor">Emb</a>      <a id="1041" class="Symbol">→</a> <a id="1043" href="Generic.Syntax.html#569" class="InductiveConstructor">`X</a> <a id="1046" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="1049" href="Generic.Syntax.Bidirectional.html#488" class="InductiveConstructor">Infer</a> <a id="1055" class="Symbol">(</a><a id="1056" href="Generic.Syntax.html#611" class="InductiveConstructor">`∎</a> <a id="1059" href="Generic.Syntax.Bidirectional.html#482" class="InductiveConstructor">Check</a><a id="1064" class="Symbol">)</a>

<a id="1067" class="Keyword">module</a> <a id="PATTERNS"></a><a id="1074" href="Generic.Syntax.Bidirectional.html#1074" class="Module">PATTERNS</a> <a id="1083" class="Keyword">where</a>

  <a id="1092" class="Keyword">pattern</a> <a id="PATTERNS.APP"></a><a id="1100" href="Generic.Syntax.Bidirectional.html#1100" class="InductiveConstructor">APP</a> <a id="1104" href="Generic.Syntax.Bidirectional.html#1123" class="Bound">f</a> <a id="1106" href="Generic.Syntax.Bidirectional.html#1127" class="Bound">t</a>  <a id="1109" class="Symbol">=</a> <a id="1111" href="Generic.Syntax.html#1338" class="InductiveConstructor">`con</a> <a id="1116" class="Symbol">(</a><a id="1117" href="Generic.Syntax.Bidirectional.html#416" class="InductiveConstructor">App</a> <a id="1121" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1123" href="Generic.Syntax.Bidirectional.html#1123" class="Bound">f</a> <a id="1125" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1127" href="Generic.Syntax.Bidirectional.html#1127" class="Bound">t</a> <a id="1129" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1131" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1135" class="Symbol">)</a>
  <a id="1139" class="Keyword">pattern</a> <a id="PATTERNS.LAM"></a><a id="1147" href="Generic.Syntax.Bidirectional.html#1147" class="InductiveConstructor">LAM</a> <a id="1151" href="Generic.Syntax.Bidirectional.html#1170" class="Bound">b</a>    <a id="1156" class="Symbol">=</a> <a id="1158" href="Generic.Syntax.html#1338" class="InductiveConstructor">`con</a> <a id="1163" class="Symbol">(</a><a id="1164" href="Generic.Syntax.Bidirectional.html#420" class="InductiveConstructor">Lam</a> <a id="1168" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1170" href="Generic.Syntax.Bidirectional.html#1170" class="Bound">b</a> <a id="1172" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1174" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1178" class="Symbol">)</a>
  <a id="1182" class="Keyword">pattern</a> <a id="PATTERNS.CUT"></a><a id="1190" href="Generic.Syntax.Bidirectional.html#1190" class="InductiveConstructor">CUT</a> <a id="1194" href="Generic.Syntax.Bidirectional.html#1211" class="Bound">σ</a> <a id="1196" href="Generic.Syntax.Bidirectional.html#1215" class="Bound">t</a>  <a id="1199" class="Symbol">=</a> <a id="1201" href="Generic.Syntax.html#1338" class="InductiveConstructor">`con</a> <a id="1206" class="Symbol">(</a><a id="1207" href="Generic.Syntax.Bidirectional.html#438" class="InductiveConstructor">Cut</a> <a id="1211" href="Generic.Syntax.Bidirectional.html#1211" class="Bound">σ</a> <a id="1213" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1215" href="Generic.Syntax.Bidirectional.html#1215" class="Bound">t</a> <a id="1217" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1219" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1223" class="Symbol">)</a>
  <a id="1227" class="Keyword">pattern</a> <a id="PATTERNS.EMB"></a><a id="1235" href="Generic.Syntax.Bidirectional.html#1235" class="InductiveConstructor">EMB</a> <a id="1239" href="Generic.Syntax.Bidirectional.html#1258" class="Bound">t</a>    <a id="1244" class="Symbol">=</a> <a id="1246" href="Generic.Syntax.html#1338" class="InductiveConstructor">`con</a> <a id="1251" class="Symbol">(</a><a id="1252" href="Generic.Syntax.Bidirectional.html#424" class="InductiveConstructor">Emb</a> <a id="1256" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1258" href="Generic.Syntax.Bidirectional.html#1258" class="Bound">t</a> <a id="1260" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1262" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1266" class="Symbol">)</a>

</pre></body></html>