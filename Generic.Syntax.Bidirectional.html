<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Generic.Syntax.Bidirectional</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Pragma">--sized-types</a> <a id="34" class="Symbol">#-}</a>

<a id="39" class="Keyword">module</a> <a id="46" href="Generic.Syntax.Bidirectional.html" class="Module">Generic.Syntax.Bidirectional</a> <a id="75" class="Keyword">where</a>

<a id="82" class="Keyword">open</a> <a id="87" class="Keyword">import</a> <a id="94" href="Data.Product.html" class="Module">Data.Product</a>
<a id="107" class="Keyword">open</a> <a id="112" class="Keyword">import</a> <a id="119" href="Agda.Builtin.List.html" class="Module">Agda.Builtin.List</a>
<a id="137" class="Keyword">open</a> <a id="142" class="Keyword">import</a> <a id="149" href="Agda.Builtin.Equality.html" class="Module">Agda.Builtin.Equality</a>
<a id="171" class="Keyword">open</a> <a id="176" class="Keyword">import</a> <a id="183" href="Function.html" class="Module">Function</a>

<a id="193" class="Keyword">open</a> <a id="198" class="Keyword">import</a> <a id="205" href="Generic.Syntax.html" class="Module">Generic.Syntax</a>

<a id="221" class="Keyword">open</a> <a id="226" class="Keyword">import</a> <a id="233" href="StateOfTheArt.ACMM.html" class="Module">StateOfTheArt.ACMM</a> <a id="252" class="Keyword">using</a> <a id="258" class="Symbol">(</a><a id="259" href="StateOfTheArt.ACMM.html#347" class="Datatype">Type</a><a id="263" class="Symbol">;</a> <a id="265" href="StateOfTheArt.ACMM.html#366" class="InductiveConstructor">α</a><a id="266" class="Symbol">;</a> <a id="268" href="StateOfTheArt.ACMM.html#380" class="InductiveConstructor Operator">_`→_</a><a id="272" class="Symbol">)</a> <a id="274" class="Keyword">public</a>

<a id="282" class="Comment">-- We have an *untyped* language presented in a bidirectional manner</a>
<a id="351" class="Comment">-- where phases are statically checked</a>


<a id="392" class="Keyword">data</a> <a id="Mode"></a><a id="397" href="Generic.Syntax.Bidirectional.html#397" class="Datatype">Mode</a> <a id="402" class="Symbol">:</a> <a id="404" class="PrimitiveType">Set</a> <a id="408" class="Keyword">where</a>
  <a id="Mode.Check"></a><a id="416" href="Generic.Syntax.Bidirectional.html#416" class="InductiveConstructor">Check</a> <a id="Mode.Infer"></a><a id="422" href="Generic.Syntax.Bidirectional.html#422" class="InductiveConstructor">Infer</a> <a id="428" class="Symbol">:</a> <a id="430" href="Generic.Syntax.Bidirectional.html#397" class="Datatype">Mode</a>

<a id="436" class="Keyword">data</a> <a id="`Bidi"></a><a id="441" href="Generic.Syntax.Bidirectional.html#441" class="Datatype">`Bidi</a> <a id="447" class="Symbol">:</a> <a id="449" class="PrimitiveType">Set</a> <a id="453" class="Keyword">where</a>
  <a id="`Bidi.App"></a><a id="461" href="Generic.Syntax.Bidirectional.html#461" class="InductiveConstructor">App</a> <a id="`Bidi.Lam"></a><a id="465" href="Generic.Syntax.Bidirectional.html#465" class="InductiveConstructor">Lam</a> <a id="`Bidi.Emb"></a><a id="469" href="Generic.Syntax.Bidirectional.html#469" class="InductiveConstructor">Emb</a> <a id="473" class="Symbol">:</a> <a id="475" href="Generic.Syntax.Bidirectional.html#441" class="Datatype">`Bidi</a>
  <a id="`Bidi.Cut"></a><a id="483" href="Generic.Syntax.Bidirectional.html#483" class="InductiveConstructor">Cut</a> <a id="487" class="Symbol">:</a> <a id="489" href="StateOfTheArt.ACMM.html#347" class="Datatype">Type</a> <a id="494" class="Symbol">→</a> <a id="496" href="Generic.Syntax.Bidirectional.html#441" class="Datatype">`Bidi</a>


<a id="504" class="Comment">-- On top of the traditional Application and Lambda-Abstraction constructors,</a>
<a id="582" class="Comment">-- we have two change of direction ones: `Emb` which takes inferable terms and</a>
<a id="661" class="Comment">-- makes them checkable (it is enough to compare the inferred type to the</a>
<a id="735" class="Comment">-- candidate provided); and `Cut` which takes a checkable term and makes it</a>
<a id="811" class="Comment">-- inferrable thanks to a type-annotation.</a>


<a id="Bidi"></a><a id="856" href="Generic.Syntax.Bidirectional.html#856" class="Function">Bidi</a> <a id="861" class="Symbol">:</a> <a id="863" href="Generic.Syntax.html#503" class="Datatype">Desc</a> <a id="868" href="Generic.Syntax.Bidirectional.html#397" class="Datatype">Mode</a>
<a id="873" href="Generic.Syntax.Bidirectional.html#856" class="Function">Bidi</a>  <a id="879" class="Symbol">=</a>  <a id="882" href="Generic.Syntax.html#533" class="InductiveConstructor">`σ</a> <a id="885" href="Generic.Syntax.Bidirectional.html#441" class="Datatype">`Bidi</a> <a id="891" href="Function.html#1927" class="Function Operator">$</a> <a id="893" class="Symbol">λ</a> <a id="895" class="Keyword">where</a>
  <a id="903" href="Generic.Syntax.Bidirectional.html#461" class="InductiveConstructor">App</a>      <a id="912" class="Symbol">→</a> <a id="914" href="Generic.Syntax.html#575" class="InductiveConstructor">`X</a> <a id="917" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="920" href="Generic.Syntax.Bidirectional.html#422" class="InductiveConstructor">Infer</a> <a id="926" class="Symbol">(</a><a id="927" href="Generic.Syntax.html#575" class="InductiveConstructor">`X</a> <a id="930" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="933" href="Generic.Syntax.Bidirectional.html#416" class="InductiveConstructor">Check</a> <a id="939" class="Symbol">(</a><a id="940" href="Generic.Syntax.html#617" class="InductiveConstructor">`∎</a> <a id="943" href="Generic.Syntax.Bidirectional.html#422" class="InductiveConstructor">Infer</a><a id="948" class="Symbol">))</a>
  <a id="953" href="Generic.Syntax.Bidirectional.html#465" class="InductiveConstructor">Lam</a>      <a id="962" class="Symbol">→</a> <a id="964" href="Generic.Syntax.html#575" class="InductiveConstructor">`X</a> <a id="967" class="Symbol">(</a><a id="968" href="Generic.Syntax.Bidirectional.html#422" class="InductiveConstructor">Infer</a> <a id="974" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="976" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="978" class="Symbol">)</a> <a id="980" href="Generic.Syntax.Bidirectional.html#416" class="InductiveConstructor">Check</a> <a id="986" class="Symbol">(</a><a id="987" href="Generic.Syntax.html#617" class="InductiveConstructor">`∎</a> <a id="990" href="Generic.Syntax.Bidirectional.html#416" class="InductiveConstructor">Check</a><a id="995" class="Symbol">)</a>
  <a id="999" class="Symbol">(</a><a id="1000" href="Generic.Syntax.Bidirectional.html#483" class="InductiveConstructor">Cut</a> <a id="1004" href="Generic.Syntax.Bidirectional.html#1004" class="Bound">σ</a><a id="1005" class="Symbol">)</a>  <a id="1008" class="Symbol">→</a> <a id="1010" href="Generic.Syntax.html#575" class="InductiveConstructor">`X</a> <a id="1013" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="1016" href="Generic.Syntax.Bidirectional.html#416" class="InductiveConstructor">Check</a> <a id="1022" class="Symbol">(</a><a id="1023" href="Generic.Syntax.html#617" class="InductiveConstructor">`∎</a> <a id="1026" href="Generic.Syntax.Bidirectional.html#422" class="InductiveConstructor">Infer</a><a id="1031" class="Symbol">)</a>
  <a id="1035" href="Generic.Syntax.Bidirectional.html#469" class="InductiveConstructor">Emb</a>      <a id="1044" class="Symbol">→</a> <a id="1046" href="Generic.Syntax.html#575" class="InductiveConstructor">`X</a> <a id="1049" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="1052" href="Generic.Syntax.Bidirectional.html#422" class="InductiveConstructor">Infer</a> <a id="1058" class="Symbol">(</a><a id="1059" href="Generic.Syntax.html#617" class="InductiveConstructor">`∎</a> <a id="1062" href="Generic.Syntax.Bidirectional.html#416" class="InductiveConstructor">Check</a><a id="1067" class="Symbol">)</a>


<a id="1071" class="Keyword">module</a> <a id="PATTERNS"></a><a id="1078" href="Generic.Syntax.Bidirectional.html#1078" class="Module">PATTERNS</a> <a id="1087" class="Keyword">where</a>

  <a id="1096" class="Keyword">pattern</a> <a id="PATTERNS.APP"></a><a id="1104" href="Generic.Syntax.Bidirectional.html#1104" class="InductiveConstructor">APP</a> <a id="1108" href="Generic.Syntax.Bidirectional.html#1127" class="Bound">f</a> <a id="1110" href="Generic.Syntax.Bidirectional.html#1131" class="Bound">t</a>  <a id="1113" class="Symbol">=</a> <a id="1115" href="Generic.Syntax.html#1394" class="InductiveConstructor">`con</a> <a id="1120" class="Symbol">(</a><a id="1121" href="Generic.Syntax.Bidirectional.html#461" class="InductiveConstructor">App</a> <a id="1125" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1127" href="Generic.Syntax.Bidirectional.html#1127" class="Bound">f</a> <a id="1129" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1131" href="Generic.Syntax.Bidirectional.html#1131" class="Bound">t</a> <a id="1133" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1135" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1139" class="Symbol">)</a>
  <a id="1143" class="Keyword">pattern</a> <a id="PATTERNS.LAM"></a><a id="1151" href="Generic.Syntax.Bidirectional.html#1151" class="InductiveConstructor">LAM</a> <a id="1155" href="Generic.Syntax.Bidirectional.html#1174" class="Bound">b</a>    <a id="1160" class="Symbol">=</a> <a id="1162" href="Generic.Syntax.html#1394" class="InductiveConstructor">`con</a> <a id="1167" class="Symbol">(</a><a id="1168" href="Generic.Syntax.Bidirectional.html#465" class="InductiveConstructor">Lam</a> <a id="1172" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1174" href="Generic.Syntax.Bidirectional.html#1174" class="Bound">b</a> <a id="1176" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1178" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1182" class="Symbol">)</a>
  <a id="1186" class="Keyword">pattern</a> <a id="PATTERNS.CUT"></a><a id="1194" href="Generic.Syntax.Bidirectional.html#1194" class="InductiveConstructor">CUT</a> <a id="1198" href="Generic.Syntax.Bidirectional.html#1215" class="Bound">σ</a> <a id="1200" href="Generic.Syntax.Bidirectional.html#1219" class="Bound">t</a>  <a id="1203" class="Symbol">=</a> <a id="1205" href="Generic.Syntax.html#1394" class="InductiveConstructor">`con</a> <a id="1210" class="Symbol">(</a><a id="1211" href="Generic.Syntax.Bidirectional.html#483" class="InductiveConstructor">Cut</a> <a id="1215" href="Generic.Syntax.Bidirectional.html#1215" class="Bound">σ</a> <a id="1217" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1219" href="Generic.Syntax.Bidirectional.html#1219" class="Bound">t</a> <a id="1221" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1223" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1227" class="Symbol">)</a>
  <a id="1231" class="Keyword">pattern</a> <a id="PATTERNS.EMB"></a><a id="1239" href="Generic.Syntax.Bidirectional.html#1239" class="InductiveConstructor">EMB</a> <a id="1243" href="Generic.Syntax.Bidirectional.html#1262" class="Bound">t</a>    <a id="1248" class="Symbol">=</a> <a id="1250" href="Generic.Syntax.html#1394" class="InductiveConstructor">`con</a> <a id="1255" class="Symbol">(</a><a id="1256" href="Generic.Syntax.Bidirectional.html#469" class="InductiveConstructor">Emb</a> <a id="1260" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1262" href="Generic.Syntax.Bidirectional.html#1262" class="Bound">t</a> <a id="1264" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1266" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1270" class="Symbol">)</a>

</pre></body></html>