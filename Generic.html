<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Generic</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="Generic.html" class="Module">Generic</a> <a id="16" class="Keyword">where</a>

<a id="23" class="Comment">--------------------------------------------------------------------------------</a>
<a id="104" class="Comment">-- STATE OF THE ART</a>
<a id="124" class="Comment">--------------------------------------------------------------------------------</a>

<a id="206" class="Comment">-- This work relies on previous efforts in dependently-typed programming:</a>
<a id="280" class="Comment">-- CDMM defines a generic universe of datatypes</a>
<a id="328" class="Keyword">import</a> <a id="335" href="StateOfTheArt.CDMM.html" class="Module">StateOfTheArt.CDMM</a>
<a id="354" class="Comment">-- ACMM defines a generic notion of semantics for a well scoped-and-typed language</a>
<a id="437" class="Keyword">import</a> <a id="444" href="StateOfTheArt.ACMM.html" class="Module">StateOfTheArt.ACMM</a>

<a id="464" class="Comment">--------------------------------------------------------------------------------</a>
<a id="545" class="Comment">-- MOTIVATION</a>
<a id="559" class="Comment">--------------------------------------------------------------------------------</a>

<a id="641" class="Comment">-- Expository problem described in the paper: two languages (S with lets, T without),</a>
<a id="727" class="Comment">-- an elaboration from S to T, two operational semantics and a desired proof:</a>
<a id="805" class="Comment">-- a simulation lemma between a term s in S and its elaboration in T.</a>

<a id="876" class="Keyword">import</a> <a id="883" href="Motivation.Problem.Naive.html" class="Module">Motivation.Problem.Naive</a>
<a id="908" class="Keyword">import</a> <a id="915" href="Motivation.Problem.WithLibrary.html" class="Module">Motivation.Problem.WithLibrary</a>

<a id="947" class="Comment">-- Solutions to the POPLMark Reloaded challenge: proving using a logical relation</a>
<a id="1029" class="Comment">-- argument the strong normalization of the Simply Typed Lambda Calculus, its</a>
<a id="1107" class="Comment">-- extensions with Sums, and finally Gödel T.</a>

<a id="1154" class="Keyword">import</a> <a id="1161" href="Motivation.POPLMark2.STLC.html" class="Module">Motivation.POPLMark2.STLC</a>
<a id="1187" class="Keyword">import</a> <a id="1194" href="Motivation.POPLMark2.Sums.html" class="Module">Motivation.POPLMark2.Sums</a>
<a id="1220" class="Keyword">import</a> <a id="1227" href="Motivation.POPLMark2.GodelT.html" class="Module">Motivation.POPLMark2.GodelT</a>


<a id="1257" class="Comment">--------------------------------------------------------------------------------</a>
<a id="1338" class="Comment">-- THE LIBRARY</a>
<a id="1353" class="Comment">--------------------------------------------------------------------------------</a>

<a id="1435" class="Comment">-- Notations for indexed types</a>
<a id="1466" class="Keyword">import</a> <a id="1473" href="Stdlib.html" class="Module">Stdlib</a>

<a id="1481" class="Comment">-- SYNTAX</a>
<a id="1491" class="Comment">--------------------------------------------------------------------------------</a>

<a id="1573" class="Comment">-- Variables as well scoped-and-sorted de Bruijn indices</a>
<a id="1630" class="Keyword">import</a> <a id="1637" href="Data.Var.html" class="Module">Data.Var</a> <a id="1646" class="Symbol">as</a> <a id="1649" class="Module">V</a>
<a id="1651" class="Keyword">import</a> <a id="1658" href="Data.Var.Varlike.html" class="Module">Data.Var.Varlike</a>

<a id="1676" class="Comment">-- Universe of Well Scoped-and-Sorted Syntaxes with Binding</a>
<a id="1736" class="Keyword">import</a> <a id="1743" href="Generic.Syntax.html" class="Module">Generic.Syntax</a>

<a id="1759" class="Comment">-- Examples of Syntaxes</a>
<a id="1783" class="Comment">-- * Well-scoped UnTyped Lambda-Calculus</a>
<a id="1824" class="Keyword">import</a> <a id="1831" href="Generic.Syntax.UTLC.html" class="Module">Generic.Syntax.UTLC</a>
<a id="1851" class="Comment">-- * Well-scopde-and-phased Bidirectional UnTyped Lambda-Calculus</a>
<a id="1917" class="Keyword">import</a> <a id="1924" href="Generic.Syntax.Bidirectional.html" class="Module">Generic.Syntax.Bidirectional</a>
<a id="1953" class="Comment">-- * Well-scoped-and-typed variants of the Simply-Typed Lambda-Calculus</a>
<a id="2025" class="Keyword">import</a> <a id="2032" href="Generic.Syntax.STLC.html" class="Module">Generic.Syntax.STLC</a>
<a id="2052" class="Keyword">import</a> <a id="2059" href="Generic.Syntax.STLC%252BState.html" class="Module">Generic.Syntax.STLC+State</a>
<a id="2085" class="Keyword">import</a> <a id="2092" href="Generic.Syntax.STLC%252BProduct.html" class="Module">Generic.Syntax.STLC+Product</a>
<a id="2120" class="Comment">-- * System F as a two-phase syntax</a>
<a id="2156" class="Keyword">import</a> <a id="2163" href="Generic.Examples.SystemF.html" class="Module">Generic.Examples.SystemF</a>

<a id="2189" class="Comment">-- Syntax extensions (single / counted / parallel) let-binders</a>
<a id="2252" class="Keyword">import</a> <a id="2259" href="Generic.Syntax.LetBinder.html" class="Module">Generic.Syntax.LetBinder</a>
<a id="2284" class="Keyword">import</a> <a id="2291" href="Generic.Syntax.LetCounter.html" class="Module">Generic.Syntax.LetCounter</a>
<a id="2317" class="Keyword">import</a> <a id="2324" href="Generic.Syntax.LetBinders.html" class="Module">Generic.Syntax.LetBinders</a>



<a id="2353" class="Comment">-- Alternative interpretation of descriptions from PHOAS to raw terms.</a>
<a id="2424" class="Comment">-- This empowers us to prove that:</a>
<a id="2459" class="Comment">-- * to each syntactic term we can associate a term in PHOAS</a>
<a id="2520" class="Comment">-- * to each raw term we can try to associate a syntactic term via *generic*</a>
<a id="2597" class="Comment">--   scopechecking</a>
<a id="2616" class="Keyword">open</a> <a id="2621" class="Keyword">import</a> <a id="2628" href="Generic.AltSyntax.html" class="Module">Generic.AltSyntax</a>

<a id="2647" class="Comment">-- SEMANTICS</a>
<a id="2660" class="Comment">--------------------------------------------------------------------------------</a>

<a id="2742" class="Comment">-- Environments as Well Scoped-and-Sorted Functions from Variables to Values</a>
<a id="2819" class="Keyword">import</a> <a id="2826" href="Data.Environment.html" class="Module">Data.Environment</a>

<a id="2844" class="Comment">-- Semantics as Well Scoped-and-Sorted Algebras on Syntaxes with Binding</a>
<a id="2917" class="Keyword">import</a> <a id="2924" href="Generic.Semantics.html" class="Module">Generic.Semantics</a>

<a id="2943" class="Comment">-- Trivial instance of a Semantics</a>
<a id="2978" class="Keyword">import</a> <a id="2985" href="Generic.Semantics.Unit.html" class="Module">Generic.Semantics.Unit</a>

<a id="3009" class="Comment">-- Renaming and Substitution as Semantics</a>
<a id="3051" class="Keyword">import</a> <a id="3058" href="Generic.Semantics.Syntactic.html" class="Module">Generic.Semantics.Syntactic</a>

<a id="3087" class="Comment">-- Generic Unsafe Normalization by Evaluation and Printing as Semantics</a>
<a id="3159" class="Keyword">import</a> <a id="3166" href="Generic.Semantics.NbyE.html" class="Module">Generic.Semantics.NbyE</a>
<a id="3189" class="Keyword">import</a> <a id="3196" href="Generic.Semantics.Printing.html" class="Module">Generic.Semantics.Printing</a>
<a id="3223" class="Comment">-- use cases:</a>
<a id="3237" class="Keyword">import</a> <a id="3244" href="Generic.Examples.NbyE.html" class="Module">Generic.Examples.NbyE</a>
<a id="3266" class="Keyword">import</a> <a id="3273" href="Generic.Examples.Printing.html" class="Module">Generic.Examples.Printing</a>

<a id="3300" class="Comment">-- Generic Elaboration of Let-binders (single &amp; parallel ones)</a>
<a id="3363" class="Keyword">import</a> <a id="3370" href="Generic.Semantics.Elaboration.LetBinder.html" class="Module">Generic.Semantics.Elaboration.LetBinder</a>
<a id="3410" class="Keyword">import</a> <a id="3417" href="Generic.Semantics.Elaboration.LetCounter.html" class="Module">Generic.Semantics.Elaboration.LetCounter</a>
<a id="3458" class="Keyword">import</a> <a id="3465" href="Generic.Semantics.Elaboration.LetBinders.html" class="Module">Generic.Semantics.Elaboration.LetBinders</a>

<a id="3507" class="Comment">-- Specific Semantics relating various examples of Syntaxes</a>
<a id="3567" class="Keyword">import</a> <a id="3574" href="Generic.Semantics.TypeChecking.html" class="Module">Generic.Semantics.TypeChecking</a>
<a id="3605" class="Keyword">import</a> <a id="3612" href="Generic.Semantics.Elaboration.State.html" class="Module">Generic.Semantics.Elaboration.State</a>
<a id="3648" class="Keyword">import</a> <a id="3655" href="Generic.Semantics.Elaboration.Typed.html" class="Module">Generic.Semantics.Elaboration.Typed</a>

<a id="3692" class="Comment">-- PROPERTIES</a>
<a id="3706" class="Comment">--------------------------------------------------------------------------------</a>

<a id="3788" class="Comment">-- Relator: Head Constructors with Related Subterms</a>
<a id="3840" class="Keyword">import</a> <a id="3847" href="Generic.Relator.html" class="Module">Generic.Relator</a>

<a id="3864" class="Comment">-- Fundamental Lemma of Logical Predicates</a>
<a id="3907" class="Keyword">import</a> <a id="3914" href="Data.Pred.html" class="Module">Data.Pred</a> <a id="3924" class="Symbol">as</a> <a id="3927" class="Module">P</a>
<a id="3929" class="Keyword">import</a> <a id="3936" href="Generic.Fundamental.html" class="Module">Generic.Fundamental</a>

<a id="3957" class="Comment">-- Generic Notion of Simulation Between Two Semantics</a>
<a id="4011" class="Keyword">import</a> <a id="4018" href="Data.Relation.html" class="Module">Data.Relation</a> <a id="4032" class="Symbol">as</a> <a id="4035" class="Module">R</a>
<a id="4037" class="Keyword">import</a> <a id="4044" href="Generic.Simulation.html" class="Module">Generic.Simulation</a>
<a id="4063" class="Keyword">import</a> <a id="4070" href="Generic.Simulation.Syntactic.html" class="Module">Generic.Simulation.Syntactic</a>

<a id="4100" class="Comment">-- Applying the Identity Substitution is the Identity</a>
<a id="4154" class="Keyword">import</a> <a id="4161" href="Generic.Identity.html" class="Module">Generic.Identity</a>

<a id="4179" class="Comment">-- FUSION</a>

<a id="4190" class="Comment">-- Generic Notion of Fusible Semantics</a>
<a id="4229" class="Keyword">import</a> <a id="4236" href="Generic.Fusion.html" class="Module">Generic.Fusion</a>

<a id="4252" class="Comment">-- Renaming and Substitution interact well with each other and let-elaboration</a>
<a id="4331" class="Keyword">import</a> <a id="4338" href="Generic.Fusion.Syntactic.html" class="Module">Generic.Fusion.Syntactic</a>
<a id="4363" class="Keyword">import</a> <a id="4370" href="Generic.Fusion.Elaboration.LetBinder.html" class="Module">Generic.Fusion.Elaboration.LetBinder</a>

<a id="4408" class="Comment">-- Based on Kaiser, Schäfer, and Stark&#39;s remark, we can concoct an axiom-free</a>
<a id="4486" class="Comment">-- specialised version of fusion for renaming-semantics interactions (it makes</a>
<a id="4565" class="Comment">-- some of the previous proofs shorter).</a>
<a id="4606" class="Comment">-- We can also use it to replicate their result assuming functional extensionality</a>
<a id="4689" class="Keyword">import</a> <a id="4696" href="Generic.Fusion.Specialised.Propositional.html" class="Module">Generic.Fusion.Specialised.Propositional</a>
<a id="4737" class="Keyword">import</a> <a id="4744" href="Generic.Fusion.Specialised.Replication.html" class="Module">Generic.Fusion.Specialised.Replication</a>



<a id="4786" class="Comment">-- SYNTAX AS A FINITE REPRESENTATION OF CYCLIC STRUCTURES</a>
<a id="4844" class="Comment">--------------------------------------------------------------------------------</a>

<a id="4926" class="Keyword">import</a> <a id="4933" href="Generic.Cofinite.html" class="Module">Generic.Cofinite</a>
<a id="4950" class="Keyword">import</a> <a id="4957" href="Generic.Examples.Colist.html" class="Module">Generic.Examples.Colist</a>
<a id="4981" class="Keyword">import</a> <a id="4988" href="Generic.Bisimilar.html" class="Module">Generic.Bisimilar</a>

</pre></body></html>